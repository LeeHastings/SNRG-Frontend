package org.snrg_nyc.ui.components;


import java.util.HashMap;
import java.util.Map;

import javafx.scene.control.TableView;
import javafx.scene.input.ScrollEvent;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.value.ObservableValue;
import javafx.geometry.Orientation;
import javafx.scene.control.ScrollBar;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableColumn.CellDataFeatures;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import javafx.scene.layout.VBox;
import javafx.util.Callback;
import javafx.util.StringConverter;

import java.util.List;
import java.util.ArrayList;

/**
 * A table that's generated by supplying a double map
 * @author Devin Hastings
 *
 * @param <Col> The type of the index on the columns
 * @param <Row> The index of the rows
 * @param <Value> The value in the table cells
 */
public class DynamicTable<Col, Row, Value> extends VBox {
	
	private Map<Col, Map<Row, Value>> map;
	
	private TableView<Row> table, rowBar;
	private TableColumn<Row, String> rowCol;
	private StringConverter<Value> converter;
	private Callback<Col, String> colFactory;
	
	public DynamicTable(
			Map<Col,Map< Row, Value>> tmap, 
			StringConverter<Value> conv,
			Callback<Col, String> colf)
	{
		setTableConverter(conv);
		setColFactory(colf);
		this.map = new HashMap<>(tmap);
		table = new TableView<>();
		table.setColumnResizePolicy(TableView.UNCONSTRAINED_RESIZE_POLICY);
		table.setMaxWidth(Double.MAX_VALUE);
		HBox.setHgrow(table, Priority.ALWAYS);
		
		rowBar = new TableView<>();
		
		List<Row> rows = new ArrayList<>();
		rowCol = new TableColumn<>("Rows");
		rowBar.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
		rowBar.getColumns().add(rowCol);
		rowBar.setMaxWidth(100);
		
		
		for(Col colVal : map.keySet()){
			for(Row row : map.get(colVal).keySet()){
				if(!rows.contains(row)){
					rows.add(row);
				}
			}
			String label = colFactory.call(colVal);
			TableColumn<Row, String> col = new TableColumn<>(label);
			col.setSortable(false);
			col.setCellValueFactory((CellDataFeatures<Row, String> data)->{
				if(map.get(colVal).containsKey(data.getValue())){
					return new SimpleStringProperty(
							converter.toString(
									map.get(colVal).get(data.getValue())));
				}
				else {
					return new SimpleStringProperty("");
				}
			});
			
			col.setCellFactory(colData->{
				EditorTableCell<Row> cell = new EditorTableCell<Row>();
				cell.setOnEditCommit(event->{
					Row key = rows.get(event.cell().getIndex());
					Value val = converter.fromString(event.newText());
					if(val == null){
						map.get(colVal).remove(key);
					}
					else {
						map.get(colVal).put(key, val);
					}
				});
				return cell;
			});

			col.setEditable(true);
			
			table.getColumns().add(col);
		}
		rowCol.setSortable(false);
		rowBar.getItems().setAll(rows);
		table.getItems().setAll(rows);
		table.setEditable(true);
		
		table.addEventFilter(ScrollEvent.SCROLL, event->event.consume());
		rowBar.addEventFilter(ScrollEvent.SCROLL, event->event.consume());
		
		ScrollBar vscroll = new ScrollBar();
		vscroll.setOrientation(Orientation.VERTICAL);
		vscroll.setMin(0);
		vscroll.setMax(rows.size());
		vscroll.valueProperty().addListener((o, oldval, newval)->{
			rowBar.scrollTo(newval.intValue());
			table.scrollTo(newval.intValue());
		});
		
		ScrollBar hscroll = new ScrollBar();
		hscroll.setOrientation(Orientation.HORIZONTAL);
		hscroll.setMin(0);
		hscroll.setMax(table.getColumns().size());
		hscroll.valueProperty().addListener((o, oldval, newval)->{
			int colVal = newval.intValue();
			if(table.getColumns().size() > colVal){
				table.scrollToColumnIndex(colVal);
			}
		});
		
		//Scroll to the edited cell
		table.editingCellProperty().addListener(
			(o, oldval, newval)->{
				if(newval != null){
					hscroll.setValue(newval.getColumn());
					vscroll.setValue(newval.getRow());
				}
			});
		
		HBox h = new HBox();
		h.getChildren().addAll(rowBar, table, vscroll);
		getChildren().addAll(h, hscroll);
	}
	public void 
	setRowLabelFactory(
			Callback<CellDataFeatures<Row, String>, ObservableValue<String>> 
			factory)
	{
		rowCol.setCellValueFactory(factory);
	}
	
	public Map<Col, Map<Row, Value>>
	getMap(){
		return map;
	}
	
	public Region
	rowLabelRegion(){
		return rowBar;
	}
	public Region
	tableRegion(){
		return table;
	}
	
	private void
	setColFactory(Callback<Col, String> c){
		if(c == null){
			throw new IllegalArgumentException(
					"Cannot have a null column factory!");
		}
		this.colFactory = c;
	}	
	private void
	setTableConverter(StringConverter<Value> converter){
		if(converter == null){
			throw new IllegalArgumentException(
					"Tried to use a null string converter");
		}
		this.converter = converter;
	}
	
}
